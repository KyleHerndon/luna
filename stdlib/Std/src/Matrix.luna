import Std.Foreign
import Std.BLAS


class Matrix:
    Matrix
    MatrixVal Int Int (Ptr Double)

    def nrows: case self of
        MatrixVal nrows _ _: nrows

    def ncols: case self of
        MatrixVal _ ncols _: ncols

    def data: case self of
        MatrixVal _ _ data: data

    def + that:
        sameDim = (self.nrows, self.ncols) == (that.nrows, that.ncols)
        case sameDim of
            False: throw "Matrix.+: different dimensions"
            True:
                res = Matrix.new self.nrows self.ncols
                dcopy (self.nrows * self.ncols) that.data 1 res.data 1
                daxpy (self.nrows * self.ncols) 1.0 self.data 1 res.data 1
                res

    def * that:
        correctDim = self.ncols == that.nrows
        case correctDim of
            False: throw "Matrix.*: invalid dimensions"
            True:
                res = Matrix.new self.nrows that.ncols
                dgemm CblasRowMajor CblasNoTrans CblasNoTrans self.nrows that.ncols self.ncols 1.0 self.data self.nrows that.data that.nrows 0.0 res.data self.nrows
                res

    def set coords val:
        (row, col) = coords
        ptr = self.data.+ ((row*self.ncols + col) * 8)
        val.write ptr

    def norm:
        case (self.nrows, self.ncols) of
            (1, _): dnrm2 self.ncols self.data 1
            (_, 1): dnrm2 self.nrows self.data 1
            _: throw "Matrix.norm: non-vector"

    def dot vec:
        case (self.nrows, self.ncols) of
            (1, _): ddot self.ncols self.data 1 vec.data 1
            (_, 1): ddot self.nrows self.data 1 vec.data 1
            _: throw "Matrix.dot: non-vector"

    def toJSON:
        (0.upto self.nrows-1).map (row: (0.upto self.ncols-1).map (col: CDouble.read (self.data.+ ((row*self.ncols + col) * 8)))) . toJSON

    def new nrows ncols:
        size = nrows * ncols * 8
        mem  = malloc size
        MatrixVal nrows ncols mem

    def _initializer val nrows ncols:
        m = Matrix.new nrows ncols
        0 . upto (nrows * ncols - 1) . each (ind: val . write (m.data.+ (ind*8)))
        m

    def zeros nrows ncols:
        _initializer 0.0 nrows ncols

    def ones nrows ncols:
        _initializer 1.0 nrows ncols

    def rand nrows ncols:
        _initializer randomReal nrows ncols

    def eye nrows ncols:
        z = zeros nrows ncols
        0 . upto (min nrows ncols - 1) . each (ind: z.set (ind, ind) 1.0)
        z

    def fromList nrows ncols vals:
        elems = nrows * ncols
        correctSize = elems == vals.length
        case correctSize of
            False: throw "Matrix.fromList: number of values do not match size"
            True:
                m = Matrix.new nrows ncols
                vals . zip (0.upto (elems-1)) . each (a: case a of (val, ind): val . write (m.data.+ (ind*8)))
                m

def min a b:
    if a < b then a else b
