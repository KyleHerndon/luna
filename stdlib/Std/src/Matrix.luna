import Std.Foreign
import Std.BLAS


class Matrix:
    nrows :: Int
    ncols :: Int
    data  :: Ptr Double

    def + that:
        sameDim = (self.nrows, self.ncols) == (that.nrows, that.ncols)
        case sameDim of
            False: throw "Matrix.+: different dimensions"
            True:
                res = newMatrix self.nrows self.ncols
                dcopy (self.nrows * self.ncols) that.data 1 res.data 1
                daxpy (self.nrows * self.ncols) 1.0 self.data 1 res.data 1
                res

    def * that:
        correctDim = self.ncols == that.nrows
        case correctDim of
            False: throw "Matrix.*: invalid dimensions"
            True:
                res = newMatrix self.nrows that.ncols
                dgemm CblasRowMajor CblasNoTrans CblasNoTrans self.nrows that.ncols self.ncols 1.0 self.data self.nrows that.data that.nrows 0.0 res.data self.nrows
                res

    def set coords val:
        (row, col) = coords
        ptr = self.data.+ ((row*self.ncols + col) * 8)
        val.write ptr

    def norm:
        case (self.nrows, self.ncols) of
            (1, _): dnrm2 self.ncols self.data 1
            (_, 1): dnrm2 self.nrows self.data 1
            _: throw "Matrix.norm: non-vector"

    def dot vec:
        case (self.nrows, self.ncols) of
            (1, _): ddot self.ncols self.data 1 vec.data 1
            (_, 1): ddot self.nrows self.data 1 vec.data 1
            _: throw "Matrix.dot: non-vector"

    def toJSON:
        (0.upto self.nrows-1).map (row: (0.upto self.ncols-1).map (col: CDouble.read (self.data.+ ((row*self.ncols + col) * 8)))) . toJSON

def newMatrix nrows ncols:
    size = nrows * ncols * 8
    mem  = malloc size
    Matrix nrows ncols mem

def zeros nrows ncols:
    _initializer 0.0 nrows ncols

def ones nrows ncols:
    _initializer 1.0 nrows ncols

def rand nrows ncols:
    _initializer randomReal nrows ncols

def min a b:
    if a < b then a else b

def eye nrows ncols:
    z = zeros nrows ncols
    0 . upto (min nrows ncols - 1) . each (ind: z.set (ind, ind) 1.0)
    z

def _initializer val nrows ncols:
    size = nrows * ncols * 8
    mem  = malloc size
    0 . upto (nrows * ncols - 1) . each (ind: val . write (mem.+ (ind*8)))
    Matrix nrows ncols mem


def newMatrixFromList nrows ncols vals:
    elems = nrows * ncols
    correctSize = elems == vals.length
    case correctSize of
        False: throw "Matrix.fromList: number of values do not match size"
        True:
            size = elems * 8
            mem = malloc size
            vals . zip (0.upto (elems-1)) . each (a: case a of (val, ind): val . write (mem.+ (ind*8)))
            Matrix nrows ncols mem
